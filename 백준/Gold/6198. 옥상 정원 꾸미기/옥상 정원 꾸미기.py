"""
O(n^2) 시간복잡도로 풀면: 6,400,000,000
O(nlogn)

dp인가?
관리인이 한 방향으로만 보니까 뒤쪽부터 dp한다고 했을 때
내 오른쪽에 있는 나보다 큰 건물이 몇 칸 떨어져있는지

10  3  7  4  12 2     -> 빌딩의 높이
[1][2][3][4][5][6]    -> 빌딩의 번호
0   0  0  1  0  0

만약 내가 오른쪽보다 크면, 더 오른쪽까지 탐색할 필요 있음.
이 때 오른쪽으로 가면서 나보다 큰놈 만날 때 까지 감... 이러면 최악의경우 o(n^2)비스무리

[아마도 공간복잡도 넘칠 풀이]
- 오른쪽부터 탐색하면서, 만난 높이들을 별도의 배열에 저장하는데
- 이 때 "가로막힘"과 만나면 배열에서 카운트를 제거한다.

10  3  7  4  12 2 기준으로
7 입장에서 오른쪽에 등장했던 숫자는 4, 12, 2 지만 2는 12에 가로막혀서 없는거나 마찬가지
즉, 가로막힌 경우 배열에서 제거한다

아아아ㅏㅏㅏㅏㅏ

긴 건물 뒤쪽은 사실상 없는 건물이나 마찬가지라는 아이디어 발전시켜보자
근데 긴 건물 뒤쪽 더 긴 건물은 고려해야함

---

왼쪽부터 본다고 했을 때, 나보다 큰 건물만 아니면 보기 가능
각 건물이 몇개를 보는지 알아아하나? 전체 합만 구하면 되는데
그럼 현재 건물이 몇개를 보지? -> x
몇개의 건물이 현재 건물을 보고있지? -> 이렇게 바꾸면 왼쪽부터 순회 가능

10: 0개
3: 1개
7: 1개
4: 2개
12: 0개
2: 1개
---
총 5개

몇 채의 건물이 보고있다는 상태는 ->
지나온 건물을 배열로 관리, 현재 건물이 마지막으로 본 건물보다 높으면 제거 -> stack?
"""

import sys

input = sys.stdin.readline

n = int(input())
arr = [int(input()) for _ in range(n)]

stack = []
res = 0
for cur in arr:
    while len(stack):
        if stack[-1] > cur:
            break

        stack.pop()

    res += len(stack)
    stack.append(cur)


print(res)
